# 笔记
## 遍历
|#|Problems|
|-|-|
|94|Binary Tree Inorder Traversal|
|101|[Symmetric Tree](###Symmetric-Tree)|
|104|[Maximum Depth of Binary Tree](###树的深度)|
|100|[Same Tree](###子树的判断)|
|110|[Balanced Binary Tree](###平衡二叉树)|
|111|[Minimum Depth of Binary Tree](###树的深度)|
|144|[Binary Tree Preorder Traversal](###前序遍历)|
|145|[Binary Tree Preorder Traversal](###后序遍历)|
|429|[N-ary Tree Level Order Traversal](###Level-Order-Traversal)|
|589|[N-ary Tree Preorder Traversal](###N-ary-Tree-Traversal)|
|572|[Subtree of Another Tree](子树的判断)|
|590|[N-ary Tree Postorder Traversal](###N-ary-Tree-Traversal)|
|987||

**序**是指遍历根结点的先后顺序。前序遍历顺序为根结点->左子树->右子树，中序则是左->根->右，后序为左->右->根。

递归的解法不做说明，前、中、后三者结构相同，区别仅仅在于获取根结点的位置。主要记录利用堆栈解决的方法。

### Symmetric Tree
判断一个树是否对称，思路是利用镜像对称的遍历方法，判断得到的遍历结果是否相同，这里将其成为左遍历和右遍历。其中左遍历就是后序遍历，而右遍历则是首先遍历右子结点的后序遍历。

### 前序遍历
对于前序遍历，核心是遇到根结点后首先遍历其本身。下面举个例子来说明堆栈的作用。有如下图所示二叉树，

图

首先将根结点加入堆栈,每次只检测栈顶结点，当堆栈为空时，遍历结束。注意向堆栈中加入结点时应先右后左，这样从栈顶pop时才能首先遍历到左子结点。

|遍历结点|堆栈|
|-|-|
|1|32|
|2|354|
|4|35|
|5|3|
|3||

因此前序遍历的结果就是遍历结点的顺序12453。

### 后序遍历
如果将后序遍历的结果倒过来，就会成首先遍历右子结点的前序遍历。因为首先遍历右子结点，与前序类似，压入堆栈的则是左子结点。同样使用之前的例子，

|遍历结点|堆栈|
|-|-|
|1|23|
|3|2|
|2|45|
|5|4|
|4||


将其遍历顺序倒过来就是后序遍历的结果45231。

### Level Order Traversal
题目要求为按层遍历，应该使用队列。遍历时需要记录每层的结点个数，每遍历一层时输出结果，最终将所有每层结果组合在一起。

如果本题不要求将每层结果打包，便不需要记录每层结点个数。

### N-ary Tree Traversal
N叉树遍历的思路与二叉树完全相同，每次在堆栈中加入结点数量不同而已。

### 树的深度
单个结点深度为1，空结点深度为0，当前结点的最大深度为左右结点深度的最大值。
最小深度计算于最大基本相同，但需多判断仅有一个子结点的情况，具体参照代码。

### 平衡二叉树
平衡二叉树的核心特征时左子结点和右子结点的深度不能大于1，因此判断一棵树是否平衡，即判断其深度之差。

### 子树的判断
子树判断的前提是判断两棵树是否相同，判断t是否为s的子树，只需递归判断t树是否与s树当前子结点下方构成的树相同。








